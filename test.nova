h = 1
# 定义函数
def is_positive(x):
    global h
    #y = False
    x = h
    h = 20
    x = h
    #y = False
    if True:
        print(x)
    return x > 0

def and_bool(a, b):
   return a and b

x = 5
x = 6
y = True
w = 1.0
w = 2
print(w)
x1 = x
x1 = 2
print("x test", x, x1)

if x == 5:
    x = 4
    xx = 5

if and_bool(True, False) and is_positive(x):
    x = x + 0

print(h)

for i in range(3):
    print(i)

z = x == 8
print("z:", z)  # 输出 true (1)
print("x:", x)  # 输出

def leibniz_pi(n_terms):
    pi = 0.0
    sign = 1.0
    print(n_terms)
    for i in range(n_terms):
        term = 1 / (2 * i + 1)
        tmp = sign * term
        pi += tmp
        sign = sign * -1

    #ss = "mem free test"
    #print(ss)
    print("pi:", pi)
    return 4 * pi

n_terms = 100000000
approx_pi = leibniz_pi(n_terms)
print(approx_pi)
print("test_f:")

s = "Hello " + "Word"
def func_loop():
    return {f = 1, h = 0}

def func_loop2(cc):
    return {f = cc, h = leibniz_pi, c = func_loop}

struct1 = { a = 1, b = 2.11, c = func_loop2}
struct2 = { a2 = struct1, b2 = 2.11}
struct3 = { a3 = struct2, b3 = 2.11}
ss1 = struct1
ss1.b = 2.12
print("ptr test:", struct1.b)
struct1.c(100)
print("test_f:", struct1.c(100).f)
print("test_f:", struct1.c(100).c().f)
struct1.c(100).h(100)
leibniz_pi(100)
approx_pi = leibniz_pi(n_terms)
print(approx_pi)
print("test_f:")
print("test_f:")
print("test_h:", struct1.c(100).h(100))
struct2.a2.b = 2.13
struct3.a3.a2.a = struct1.c(100).f
print(s, approx_pi, struct3.a3.a2.a, struct1.b)

class AAA:
    aaa_b = 123
    def aa(self):
        self.var = 112
        c = 0
        print(c)
        return 0

AAA.aaa_b = 1
print("aaa_b:", AAA.aaa_b)
aaa = AAA
bbb = aaa
print(bbb.aaa_b)

class BBB(AAA):
    def bb(self):
        return AAA()

obj_a = AAA()
print(obj_a.aaa_b)
obj_a.aa()
print(obj_a.aa())
print(obj_a.var)
obj_b = BBB()
print(obj_b.aa())
#print(value)